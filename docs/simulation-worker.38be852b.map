{"version":3,"sources":["simulation/neighbors.ts","simulation/behavior/orbits.ts","simulation/behavior/behavior.ts","simulation/bounding/centerScaling.ts","simulation/bounding/bounding.ts","simulation/simulation-worker.ts"],"names":[],"mappings":"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","file":"simulation-worker.38be852b.map","sourceRoot":"../src","sourcesContent":["import { Particle } from \"./particle\";\nimport { subtract, getMagnitude } from \"./vector-n\";\nimport { map, each } from \"../util\";\n\n/**\n * A relation from one Particle to another\n */\nexport interface Neighbor {\n  index: number;\n  distance: number;\n  delta: Float32Array;\n}\n\n/**\n * Each Particle's Neighbor list, by self-same index\n */\nexport type Neighborhood = Neighbor[][];\n\n/**\n * Calculate the Neighbor[] list for each Particle\n */\nexport const getNeighborhood = (particles: Particle[]): Neighborhood =>\n  map(particles, particle => {\n    const neighbors: Neighbor[] = [];\n\n    // Find relation with every other Particle\n    each(particles, (other, index) => {\n      if (particle === other) return;\n      const delta = subtract(particle.position, other.position);\n      const distance = getMagnitude(delta);\n      return { index, delta, distance };\n    });\n\n    // Sort relations by nearest -> furthest\n    neighbors.sort((a, b) => a.distance - b.distance);\n\n    return neighbors;\n  });\n","import { BehaviorNames, Behavior } from \"./behavior\";\nimport { each, clamp } from \"../../util\";\nimport {\n  multiply,\n  getMagnitudeSq,\n  setMagnitude,\n  divide,\n  add\n} from \"../vector-n\";\n\nexport interface OrbitsSpec {\n  name: BehaviorNames.Orbits;\n  config: {\n    mass: {\n      g: number;\n      orbiter: number;\n      attractor: number;\n    };\n    distance: {\n      min: number;\n      max: number;\n    };\n  };\n}\n\nexport const orbits: Behavior<OrbitsSpec> = (\n  particles,\n  _neighborhood,\n  config\n) => {\n  // Attract each particle to the center\n  const minDistSq = config.distance.min * config.distance.min;\n  const maxDistSq = config.distance.max * config.distance.max;\n  const mass = config.mass;\n  each(particles, particle => {\n    let force = multiply(particle.position, -1); // vector to center\n    const distanceSq = clamp(getMagnitudeSq(force), minDistSq, maxDistSq);\n    const strength = (mass.g * mass.attractor * mass.orbiter) / distanceSq;\n    force = setMagnitude(force, strength);\n    force = divide(force, config.mass.orbiter);\n    particle.acceleration = add(particle.acceleration, force);\n  });\n};\n","import { Neighborhood } from \"./../neighbors\";\nimport { Particle } from \"../particle\";\nimport { OrbitsSpec, orbits } from \"./orbits\";\n\nexport type BehaviorSpecs = OrbitsSpec;\n\nexport type Behavior<Spec extends BehaviorSpecs> = (\n  particles: Particle[],\n  neighborhood: Neighborhood,\n  config: Spec[\"config\"]\n) => void;\n\nexport enum BehaviorNames {\n  Orbits = \"orbits\"\n}\n\nconst behaviors: { [name in BehaviorNames]: Behavior<BehaviorSpecs> } = {\n  orbits\n};\n\nexport const behavior = (\n  particles: Particle[],\n  neighborhood: Neighborhood,\n  spec: BehaviorSpecs\n) => behaviors[spec.name](particles, neighborhood, spec.config);\n","import { getMagnitudeSq, multiply } from \"./../vector-n\";\nimport { Bounding } from \"./bounding\";\nimport { reduce, each } from \"../../util\";\n\nexport const centerScaling: Bounding = (particles, radius) => {\n  if (particles.length < 1) return;\n\n  // Avoid Math.sqrt\n  const radiusSq = radius * radius;\n\n  // Find longest distance between individual particle & origin\n  const largestMagnitudeSq = reduce(\n    particles,\n    (memo: number, p) => Math.max(memo, getMagnitudeSq(p.position)),\n    0\n  );\n\n  // Abort if already within limits\n  if (largestMagnitudeSq <= radiusSq) return;\n\n  // Scale down all particle positions\n  const factor = radiusSq / largestMagnitudeSq;\n  each(particles, p => (p.position = multiply(p.position, factor)));\n};\n","import { Particle } from \"../particle\";\nimport { centerScaling } from \"./centerScaling\";\n\nexport type Bounding = (particles: Particle[], radius: number) => void;\n\nexport enum BoundingNames {\n  CenterScaling = \"centerScaling\"\n}\n\nconst boundings: { [name in BoundingNames]: Bounding } = {\n  centerScaling\n};\n\nexport const bounding = (\n  particles: Particle[],\n  radius: number,\n  name: BoundingNames\n) => boundings[name](particles, radius);\n","import { Neighborhood, getNeighborhood } from \"./neighbors\";\nimport { limitMagnitude, add } from \"./vector-n\";\nimport { Particle } from \"./particle\";\nimport { multiply } from \"./vector-n\";\nimport { assertNever, each } from \"../util\";\nimport { BehaviorSpecs, behavior, BehaviorNames } from \"./behavior/behavior\";\nimport { BoundingNames, bounding } from \"./bounding/bounding\";\n\nexport interface SimulationConfig {\n  behaviorSpec: BehaviorSpecs;\n  boundingName: BoundingNames;\n  max: {\n    force: number;\n    speed: number;\n    radius: number;\n  };\n}\n\nexport interface SimulationData {\n  particles: Particle[];\n  neighborhood: Neighborhood;\n}\n\nexport type WorkerMessage =\n  | { type: \"init\"; particles: Particle[]; config?: SimulationConfig }\n  | { type: \"tick\" }\n  | { type: \"destroy\" };\n\n/**\n * TypeScript currently does not support loading both \"DOM\" and \"WebWorker\"\n * type definitions (in the tsconfig \"lib\" field), so we are falling back to\n * incomplete types hacked out of the desired definitions file\n *\n * Issue:\n * https://github.com/Microsoft/TypeScript/issues/20595\n *\n * Hack:\n * node_modules/typescript/lib/lib.webworker.d.ts -> typings/custom.d.ts\n *\n * Actual:\n * https://developer.mozilla.org/en-US/docs/Web/API/DedicatedWorkerGlobalScope\n *\n */\nconst context = self as any;\n// TODO const context = (self as any) as DedicatedWorkerGlobalScope;\n\nconst DEFAULT_CONFIG = {\n  behaviorSpec: {\n    name: BehaviorNames.Orbits,\n    config: {\n      mass: {\n        g: 1,\n        orbiter: 1,\n        attractor: 1\n      },\n      distance: {\n        min: 1,\n        max: 1\n      }\n    }\n  },\n  boundingName: BoundingNames.CenterScaling,\n  max: {\n    force: 1,\n    speed: 1,\n    radius: 100\n  }\n};\n\nconst simulation: {\n  config: SimulationConfig;\n  data: SimulationData;\n} = {\n  config: DEFAULT_CONFIG,\n  data: {\n    particles: [],\n    neighborhood: []\n  }\n};\n\nconst isWorkerMessage = (val: any): val is WorkerMessage =>\n  val && typeof val.type === \"string\"; // safe enough\n\ncontext.addEventListener(\"message\", (e: MessageEvent) => {\n  const message = JSON.parse(e.data);\n  if (!isWorkerMessage(message)) return;\n  switch (message.type) {\n    case \"init\": {\n      simulation.config = message.config || DEFAULT_CONFIG;\n      simulation.data.particles = message.particles;\n      simulation.data.neighborhood = getNeighborhood(message.particles);\n      break;\n    }\n\n    case \"tick\": {\n      tick();\n      context.postMessage(JSON.stringify(simulation.data));\n      break;\n    }\n\n    case \"destroy\": {\n      context.close();\n      break;\n    }\n\n    default: {\n      assertNever(message);\n    }\n  }\n});\n\nconst tick = () => {\n  // Reset accelerations\n  each(\n    simulation.data.particles,\n    p => (p.acceleration = multiply(p.acceleration, 0))\n  );\n\n  // Apply particle behavior\n  behavior(\n    simulation.data.particles,\n    simulation.data.neighborhood,\n    simulation.config.behaviorSpec\n  );\n\n  // Update positions\n  each(simulation.data.particles, p => {\n    p.velocity = add(p.velocity, p.acceleration);\n    p.velocity = limitMagnitude(p.velocity, simulation.config.max.speed);\n    p.position = add(p.position, p.velocity);\n  });\n\n  // Apply particle bounding\n  bounding(\n    simulation.data.particles,\n    simulation.config.max.radius,\n    simulation.config.boundingName\n  );\n\n  // Re-calculate Particle relations\n  simulation.data.neighborhood = getNeighborhood(simulation.data.particles);\n};\n"]}