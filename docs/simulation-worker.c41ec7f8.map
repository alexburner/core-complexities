{"version":3,"sources":["simulation/vector-n.ts","simulation/behavior/orbits.ts","simulation/behavior/behavior.ts","simulation/bounding/centerScaling.ts","simulation/bounding/bounding.ts","simulation/neighbors.ts","simulation/simulation-worker.ts"],"names":[],"mappings":"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","file":"simulation-worker.c41ec7f8.map","sourceRoot":"../src","sourcesContent":["import { coinFlip, shuffle } from '../util'\n\nexport type Vector = Float32Array\ntype VectorMath = (a: Vector, b: Vector | number) => Vector\ntype NumberMath = (an: number, bn: number) => number\n\nconst curryMath = (math: NumberMath): VectorMath => (a, b) => {\n  const c: Vector = new Float32Array(a.length)\n  const isNumB = typeof b === 'number'\n  for (let i = 0, l = a.length; i < l; i++) {\n    const an = a[i]\n    const bn = isNumB ? (b as number) : (b as Vector)[i]\n    c[i] = math(an, bn)\n  }\n  return c\n}\n\nexport const add: VectorMath = curryMath((an, bn) => an + bn)\nexport const subtract: VectorMath = curryMath((an, bn) => an - bn)\nexport const multiply: VectorMath = curryMath((an, bn) => an * bn)\nexport const divide: VectorMath = curryMath((an, bn) => an / bn)\n\nexport const getDistanceSq = (a: Vector, b: Vector): number => {\n  const delta = subtract(a, b)\n  return getMagnitudeSq(delta)\n}\n\nexport const getDistance = (a: Vector, b: Vector): number =>\n  Math.sqrt(getDistanceSq(a, b))\n\nexport const getMagnitudeSq = (v: Vector): number => {\n  let magnitudeSq = 0\n  for (let i = 0, l = v.length; i < l; i++) {\n    magnitudeSq += v[i] * v[i]\n  }\n  return magnitudeSq\n}\n\nexport const getMagnitude = (v: Vector): number => Math.sqrt(getMagnitudeSq(v))\n\nexport const setMagnitude = (v: Vector, magnitude: number): Vector => {\n  const prevMagnitude = getMagnitude(v)\n  return prevMagnitude === 0\n    ? add(v, Math.sqrt(magnitude / v.length))\n    : multiply(v, magnitude / prevMagnitude)\n}\n\nexport const limitMagnitude = (v: Vector, limit: number): Vector => {\n  const limitSq = limit * limit\n  const currSq = getMagnitudeSq(v)\n  return currSq > limitSq ? multiply(v, limitSq / currSq) : v\n}\n\nexport const getAverage = (vectors: Vector[]): Vector => {\n  if (vectors.length === 0) throw new Error('Cannot average zero vectors')\n  const count = vectors.length\n  const dimensions = vectors[0].length\n  const average: Vector = new Float32Array(dimensions)\n  for (let i = 0; i < count; i++) {\n    for (let j = 0; j < dimensions; j++) {\n      average[j] = average[j] + vectors[i][j] / count\n    }\n  }\n  return average\n}\n\nexport const radialRandomVector = (\n  length: number,\n  radius: number = 1,\n): Vector => {\n  // Algorithm via Colin Ballast\n  const result = new Float32Array(length)\n  let radiusSq = radius * radius\n  for (let i = 0; i < length; i++) {\n    const value = Math.random() * Math.sqrt(radiusSq)\n    const valueSq = value * value\n    radiusSq -= valueSq\n    result[i] = coinFlip() ? value : -value\n  }\n  shuffle(result)\n  return result\n}\n\nexport const backfill = (newV: Vector, oldV: Vector): Vector => {\n  const filled: Vector = new Float32Array(newV.length)\n  for (let i = 0, l = newV.length; i < l; i++) {\n    filled[i] = i < oldV.length ? oldV[i] : newV[i]\n  }\n  return filled\n}\n","import { clamp, each } from '../../util'\nimport {\n  add,\n  divide,\n  getMagnitudeSq,\n  multiply,\n  setMagnitude,\n} from '../vector-n'\nimport { Behavior, BehaviorNames } from './behavior'\n\nexport interface OrbitsSpec {\n  name: BehaviorNames.Orbits\n  config: {\n    mass: {\n      g: number\n      orbiter: number\n      attractor: number\n    }\n    distance: {\n      min: number\n      max: number\n    }\n  }\n}\n\nexport const orbits: Behavior<OrbitsSpec> = (\n  particles,\n  _neighborhood,\n  config,\n) => {\n  // Attract each particle to the center\n  const minDistSq = config.distance.min * config.distance.min\n  const maxDistSq = config.distance.max * config.distance.max\n  const mass = config.mass\n  each(particles, particle => {\n    let force = multiply(particle.position, -1) // vector to center\n    const distanceSq = clamp(getMagnitudeSq(force), minDistSq, maxDistSq)\n    const strength = (mass.g * mass.attractor * mass.orbiter) / distanceSq\n    force = setMagnitude(force, strength)\n    force = divide(force, config.mass.orbiter)\n    particle.acceleration = add(particle.acceleration, force)\n  })\n}\n","import { Particle } from '../particle'\nimport { Neighborhood } from './../neighbors'\nimport { orbits, OrbitsSpec } from './orbits'\n\nexport type BehaviorSpecs = OrbitsSpec\n\nexport type Behavior<Spec extends BehaviorSpecs> = (\n  particles: Particle[],\n  neighborhood: Neighborhood,\n  config: Spec['config'],\n) => void\n\nexport enum BehaviorNames {\n  Orbits = 'orbits',\n}\n\nconst behaviors: { [name in BehaviorNames]: Behavior<BehaviorSpecs> } = {\n  orbits,\n}\n\nexport const behavior = (\n  particles: Particle[],\n  neighborhood: Neighborhood,\n  spec: BehaviorSpecs,\n) => behaviors[spec.name](particles, neighborhood, spec.config)\n","import { each, reduce } from '../../util'\nimport { getMagnitudeSq, multiply } from './../vector-n'\nimport { Bounding } from './bounding'\n\nexport const centerScaling: Bounding = (particles, radius) => {\n  if (particles.length < 1) return\n\n  // Avoid Math.sqrt\n  const radiusSq = radius * radius\n\n  // Find longest distance between individual particle & origin\n  const largestMagnitudeSq = reduce(\n    particles,\n    (memo: number, p) => Math.max(memo, getMagnitudeSq(p.position)),\n    0,\n  )\n\n  // Abort if already within limits\n  if (largestMagnitudeSq <= radiusSq) return\n\n  // Scale down all particle positions\n  const factor = radiusSq / largestMagnitudeSq\n  each(particles, p => (p.position = multiply(p.position, factor)))\n}\n","import { Particle } from '../particle'\nimport { centerScaling } from './centerScaling'\n\nexport type Bounding = (particles: Particle[], radius: number) => void\n\nexport enum BoundingNames {\n  CenterScaling = 'centerScaling',\n}\n\nconst boundings: { [name in BoundingNames]: Bounding } = {\n  centerScaling,\n}\n\nexport const bounding = (\n  particles: Particle[],\n  radius: number,\n  name: BoundingNames,\n) => boundings[name](particles, radius)\n","import { each, map } from '../util'\nimport { Particle } from './particle'\nimport { getMagnitude, subtract, Vector } from './vector-n'\n\n/**\n * A relation from one Particle to another\n */\nexport interface Neighbor {\n  index: number\n  distance: number\n  delta: Vector\n}\n\n/**\n * Each Particle's Neighbor list, by self-same index\n */\nexport type Neighborhood = Neighbor[][]\n\n/**\n * Calculate the Neighbor[] list for each Particle\n */\nexport const getNeighborhood = (particles: Particle[]): Neighborhood =>\n  map(particles, particle => {\n    const neighbors: Neighbor[] = []\n\n    // Find relation with every other Particle\n    each(particles, (other, index) => {\n      if (particle === other) return\n      const delta = subtract(particle.position, other.position)\n      const distance = getMagnitude(delta)\n      return { index, delta, distance }\n    })\n\n    // Sort relations by nearest -> furthest\n    neighbors.sort((a, b) => a.distance - b.distance)\n\n    return neighbors\n  })\n","import { assertNever, each } from '../util'\nimport { behavior, BehaviorNames, BehaviorSpecs } from './behavior/behavior'\nimport { bounding, BoundingNames } from './bounding/bounding'\nimport { getNeighborhood, Neighborhood } from './neighbors'\nimport { Particle } from './particle'\nimport { add, limitMagnitude, multiply } from './vector-n'\n\nexport interface SimulationConfig {\n  behaviorSpec: BehaviorSpecs\n  boundingName: BoundingNames\n  max: {\n    force: number\n    speed: number\n    radius: number\n  }\n}\n\nexport interface SimulationData {\n  particles: Particle[]\n  neighborhood: Neighborhood\n}\n\nexport type WorkerMessage =\n  | { type: 'init'; particles: Particle[]; config?: SimulationConfig }\n  | { type: 'tick' }\n  | { type: 'destroy' }\n\n/**\n * TypeScript currently does not support loading both \"DOM\" and \"WebWorker\"\n * type definitions (in the tsconfig \"lib\" field), so we are falling back to\n * incomplete types hacked out of the desired definitions file\n *\n * Issue:\n * https://github.com/Microsoft/TypeScript/issues/20595\n *\n * Hack:\n * node_modules/typescript/lib/lib.webworker.d.ts -> typings/custom.d.ts\n *\n * Actual:\n * https://developer.mozilla.org/en-US/docs/Web/API/DedicatedWorkerGlobalScope\n *\n */\nconst context = self as any\n// TODO const context = (self as any) as DedicatedWorkerGlobalScope;\n\nconst DEFAULT_CONFIG = {\n  behaviorSpec: {\n    name: BehaviorNames.Orbits,\n    config: {\n      mass: {\n        g: 1,\n        orbiter: 10,\n        attractor: 30,\n      },\n      distance: {\n        min: 50,\n        max: 250,\n      },\n    },\n  },\n  boundingName: BoundingNames.CenterScaling,\n  max: {\n    force: 1,\n    speed: 1,\n    radius: 50,\n  },\n}\n\nconst simulation: {\n  config: SimulationConfig\n  data: SimulationData\n} = {\n  config: DEFAULT_CONFIG,\n  data: {\n    particles: [],\n    neighborhood: [],\n  },\n}\n\nconst isWorkerMessage = (val: any): val is WorkerMessage =>\n  val && typeof val.type === 'string' // safe enough\n\ncontext.addEventListener('message', (e: MessageEvent) => {\n  const message = e.data\n  if (!isWorkerMessage(message)) return\n  switch (message.type) {\n    case 'init': {\n      simulation.config = message.config || DEFAULT_CONFIG\n      simulation.data.particles = message.particles\n      simulation.data.neighborhood = getNeighborhood(message.particles)\n      break\n    }\n\n    case 'tick': {\n      tick()\n      context.postMessage(simulation.data)\n      break\n    }\n\n    case 'destroy': {\n      context.close()\n      break\n    }\n\n    default: {\n      assertNever(message)\n    }\n  }\n})\n\nconst tick = () => {\n  // Reset accelerations\n  each(\n    simulation.data.particles,\n    p => (p.acceleration = multiply(p.acceleration, 0)),\n  )\n\n  // Apply particle behavior\n  behavior(\n    simulation.data.particles,\n    simulation.data.neighborhood,\n    simulation.config.behaviorSpec,\n  )\n\n  // Update positions\n  each(simulation.data.particles, p => {\n    p.velocity = add(p.velocity, p.acceleration)\n    p.velocity = limitMagnitude(p.velocity, simulation.config.max.speed)\n    p.position = add(p.position, p.velocity)\n  })\n\n  // Apply particle bounding\n  bounding(\n    simulation.data.particles,\n    simulation.config.max.radius,\n    simulation.config.boundingName,\n  )\n\n  // Re-calculate Particle relations\n  simulation.data.neighborhood = getNeighborhood(simulation.data.particles)\n}\n"]}